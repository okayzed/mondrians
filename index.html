<html>
  <head>

    <style>
      html, body {
        height: 100%;
        width: 100%;
        overflow: hidden;
      }
    </style>

  </head>
  <body>
    <!--     Imports -->

    <script src="canvg.js" type="text/javascript" ></script>
    <script src="raphael-min.js" type="text/javascript" ></script>

    <script>
      function randomChoice(arr) {
        var idx = parseInt(Math.random() * arr.length, 10);
        return arr[idx];
      }

      var palette = [
        '#FFFF00',
        '#FF2600',
        '#0101A3'
      ];

      function colorRect(rect, gradient) {
        var color_str = randomChoice(palette);
        var color = Raphael.color(color_str);

        if (gradient) {
          h_color = Raphael.hsl(color.h, color.s, color.l);
          color.l += 0.1;
          h_next_color = Raphael.hsl(color.h, color.s, color.l);

          rect.attr('gradient', '90-' + h_color + '-' + h_next_color +
            (Math.random() > 0.5 ? ':10' : ':70'));
          rect.node.parentNode.appendChild(rect.node); // raise the rect to top of stack

          if (rect.parent) { rect.parent.remove(); rect.parent = null; }
        } else {
          rect.attr('fill', color_str);
        }
      }

      var ids = 0;
      function newRectFactory(paper, rects) {
        function newRect(x, y, w, h) {
          var rect = paper.rect(x,y,w,h);
          rect.attr('stroke-width', '3px');
          rect.attr("stroke-color", "#1F1A18");
          rect.__id = ids++;


          rects.push(rect);
          return rect;
        }

        return newRect;
      }
    </script>

    <script>
      function buildSkeletonRects(paper, splits) {
        var rects = [];
        var newRect = newRectFactory(paper, rects);


        var min_side_size = 40;
        var offset = 20;
        var rect = newRect(-offset, -offset,
          paper.width + offset, paper.height + offset);
        rect.attr('stroke-width', '0px');

        for (var i = 0; i < splits; i++) {
          var cur_rect = randomChoice(rects);
          console.log("splitting", cur_rect.__id);

          var x = cur_rect.attr('x'),
              y = cur_rect.attr('y'),
              w = cur_rect.attr('width'),
              h = cur_rect.attr('height');

          if (w < min_side_size || h < min_side_size) {
            continue;
          }

          var w_factor = parseInt(Math.log(w * w), 10);
          var h_factor = parseInt(Math.log(h * h), 10);

          new_w = parseInt(w / 2, 10); // default to splitting in half
          new_h = parseInt(h / 2, 10); // default to splitting in half

          // And then split the log of the square
          if (Math.random() > 0.5) {
            var new_w = parseInt(w / w_factor, 10);
          } else {
            var new_h = parseInt(h / h_factor, 10);
          }

          if (h - new_h < min_side_size || h < min_side_size) {
            continue;
          }

          if (w - new_w < min_side_size || w < min_side_size) {
            continue;
          }

          var new_rect = newRect(x + new_w, y + new_h, w - new_w, h - new_h);
          var old_rect = newRect(x, y, new_w, new_h);

          // Setup the rectangle hierarchy
          new_rect.parent = old_rect.parent = cur_rect;

          if (!cur_rect.children) {
            cur_rect.children = [];
          }

          cur_rect.children.push(new_rect);
          cur_rect.children.push(old_rect);
        }

        return rects;
      }
    </script>

    <script>
      function paintRects(rects) {
        var paintability = 0.2;
        var paintable_rects = rects.filter(function(r) {
          return !r.children || !r.children.length;
        });

        for (var i = 0; i < paintable_rects.length; i++) {
          if (Math.random() < paintability) {
            var rect = paintable_rects[i];
            colorRect(rect);
          }
        }

        return rects;
      }

      function textureRects(rects) {

        for (var i = 0; i < rects.length; i++) {
          if (rects[i].children) { continue; }
          rects[i].blur();

        }
        return rects;
      }

      function explodeRects(paper, rects) {
        var explodability = 0.1;
        var returned_rects = [];
        var newRect = newRectFactory(paper, returned_rects);
        for (var i = 0; i < rects.length; i++) {
          var r = rects[i];

          var piece_size = parseInt(Math.random() * 10 + 20, 10);
          var x = r.attr('x');
          var y = r.attr('y');
          var w = r.attr('width');
          var h = r.attr('height');

          if (Math.random() < explodability && !r.children && w * h > 400) {
            var w_pieces = parseInt(w / piece_size, 10);
            var h_pieces = parseInt(h / piece_size, 10);
            w_piece_size = w / w_pieces;
            h_piece_size = h / h_pieces;

            if (w_pieces >= 3 && h_pieces >= 3) {
              continue;
            }

            if (w_pieces < 1 || h_pieces < 1) {
              continue;
            }


            for (var i = 0; i < w_pieces; i++) {
              for (var j = 0; j < h_pieces; j++) {
                var rect = newRect(
                  (i * w_piece_size) + x,
                  (j * h_piece_size) + y,
                  Math.max(w_piece_size + 1, w - ((i+1) * w_piece_size + 1)),
                  Math.max(h_piece_size + 1, h - ((j+1) * h_piece_size + 1)));

                colorRect(rect);
                rect.attr('stroke-width', '0px');
              }
            }

            r.attr("stroke-width", "3px");
            // Make it so that the exploded rect still has an outline by
            // putting the exploded rect above all its children
            r.node.parentNode.appendChild(r.node); 

            console.log("Exploding ", r.__id, " into ", h_pieces * w_pieces, "pieces");

          }

        }

        return returned_rects;
      }

      function paveBoardwalks(rects) {
        return rects;
      }
    </script>

    <script>
      var w = screen.availWidth, h = screen.availHeight;
      var splits = 10;
      var paper = Raphael(0, 0, w, h);

      var skeleton_rects = buildSkeletonRects(paper, splits);
      var exploded_rects = explodeRects(paper, skeleton_rects);

      var painted_rects = paintRects(skeleton_rects);
//      var textured_rects = textureRects(painted_rects);

      var boardwalks = paveBoardwalks(skeleton_rects);




    </script>
  </body>
</html>
