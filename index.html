<html>
  <head>

    <style>
      html, body {
        height: 100%;
        width: 100%;
        overflow: hidden;
      }
    </style>

  </head>
  <body>
    <!--     Imports -->

    <script src="canvg.js" type="text/javascript" ></script>
    <script src="raphael-min.js" type="text/javascript" ></script>

    <script>
      function randomChoice(arr) {
        var idx = parseInt(Math.random() * arr.length, 10);
        return arr[idx];
      }

      // Generates a fuzzy number close to N
      // Params: 
      //   fuzzy(n, jitter)
      //   fuzzy(n, jitter_low, jitter_high);
      function fuzzy() {
        var args = Array.prototype.slice.call(arguments);
        var n = args.shift();

        var jitter_high = 1,
            jitter_low = 1;

        if (args.length) {
          jitter_high = args.shift();
          jitter_low = jitter_high;
        }

        if (args.length) {
          jitter_high = args.shift();
        }

        var range = Math.abs(jitter_high) + Math.abs(jitter_low);
        var jitter = Math.random() * range - jitter_low;

        var ret = Math.round(n + jitter);

        return ret;
      }

      function rounded(n, mod) {
        return Math.round(n / mod) * mod;
      }

      var palette = [
        '#FFFF00',
        '#FF2600',
        '#0101A3'
      ];

      var boogie_palette = [
        '#FFFF00',
        '#FF2600',
        '#0101A3',
        '#FFFF38',
        '#FFFF10',
        '#FFFF20'
      ];



      function colorRect(rect, gradient, boogie) {
        var color_str = randomChoice(boogie ? boogie_palette : palette);
        var color = Raphael.color(color_str);

        if (gradient) {
          h_color = Raphael.hsl(color.h, color.s, color.l);
          color.l += 0.1;
          h_next_color = Raphael.hsl(color.h, color.s, color.l);

          rect.attr('gradient', '90-' + h_color + '-' + h_next_color +
            (Math.random() > 0.5 ? ':10' : ':70'));
        } else {
          rect.attr('fill', color_str);
        }

        // raise the rect to top of stack
        rect.node.parentNode.appendChild(rect.node); 
      }

      var ids = 0;
      function newRectFactory(paper, rects, border) {
        function newRect(x, y, w, h) {
          var rect = paper.rect(x,y,w,h);
          if (!border) {
            rect.attr('stroke-width', '0px');
          } else {
            rect.attr('stroke-width', '3px');
          }

          rect.attr("stroke-color", "#1F1A18");
          rect.__id = ids++;


          rects.push(rect);
          return rect;
        }

        return newRect;
      }

      function getBox(r) {
          var x = r.attr('x');
          var y = r.attr('y');
          var w = r.attr('width');
          var h = r.attr('height');

          return [x, y, w, h];
      }
    </script>

    <script>
      function buildSkeletonRects(paper, splits, boogie) {
        var rects = [];
        var newRect = newRectFactory(paper, rects, !boogie /* add borders */);


        var min_side_size = 40;
        var offset = 30;
        var rect = newRect(-offset, -offset,
          paper.width + offset, paper.height + offset);
        rect.attr('stroke-width', '0px');

        for (var i = 0; i < splits; i++) {
          var cur_rect = randomChoice(rects);

          var x = cur_rect.attr('x'),
              y = cur_rect.attr('y'),
              w = cur_rect.attr('width'),
              h = cur_rect.attr('height');

          if (w < min_side_size || h < min_side_size) {
            continue;
          }

          var w_factor = parseInt(Math.log(Math.random() * w * w * w), 10);
          var h_factor = parseInt(Math.log(Math.random() * h * h * h), 10);

          new_w = parseInt(w / 2, 10); // default to splitting in half
          new_h = parseInt(h / 2, 10); // default to splitting in half

          // And then split the log of the square
          if (Math.random() > 0.5) {
            var new_w = parseInt(w / w_factor, 10);
          } else {
            var new_h = parseInt(h / h_factor, 10);
          }

          if (h - new_h < min_side_size || h < min_side_size) {
            continue;
          }

          if (w - new_w < min_side_size || w < min_side_size) {
            continue;
          }

          var new_rect = newRect(x + new_w, y + new_h, w - new_w, h - new_h);
          var old_rect = newRect(x, y, new_w, new_h);

          // Setup the rectangle hierarchy
          new_rect.parent = old_rect.parent = cur_rect;

          if (!cur_rect.children) {
            cur_rect.children = [];
            var parent = cur_rect.parent;
            while (parent) {
              if (!parent.children) { parent.children = true; };
              parent = parent.parent;
            }
          }

          cur_rect.children.push(new_rect);
          cur_rect.children.push(old_rect);
        }

        return rects;
      }
    </script>

    <script>
      function paintRects(rects) {
        var paintability = 0.2;
        var paintable_rects = rects.filter(function(r) {
          return !r.children;
        });

        for (var i = 0; i < paintable_rects.length; i++) {
          if (Math.random() < paintability) {
            var rect = paintable_rects[i];
            colorRect(rect);
          }
        }

        return rects;
      }

      function textureRects(rects) {

        for (var i = 0; i < rects.length; i++) {
          if (rects[i].children) { continue; }
          rects[i].blur();

        }
        return rects;
      }

      function explodeRect(r, piece_size, newRect, boogie) {
        var b = getBox(r),x=b[0],y=b[1],w=b[2],h=b[3];
        var w_pieces = parseInt(w / piece_size, 10);
        var h_pieces = parseInt(h / piece_size, 10);
        w_piece_size = w / w_pieces;
        h_piece_size = h / h_pieces;


        if (w_pieces >= 3 && h_pieces >= 3) {
          return;
        }

        if (w_pieces < 1 || h_pieces < 1) {
          return;
        }


        for (var i = 0; i < w_pieces; i++) {
          for (var j = 0; j < h_pieces; j++) {
            var rect = newRect(
              (i * w_piece_size) + x,
              (j * h_piece_size) + y,
              Math.max(w_piece_size + 1, w - ((i+1) * w_piece_size + 1)),
              Math.max(h_piece_size + 1, h - ((j+1) * h_piece_size + 1)));

            colorRect(rect, false, boogie);
            rect.attr('stroke-width', '0px');
          }
        }

        // Make it so that the exploded rect still has an outline by
        // putting the exploded rect above all its children
        r.node.parentNode.appendChild(r.node);


      }

      function explodeRects(paper, rects) {
        var explodability = 0.1;
        var returned_rects = [];
        var newRect = newRectFactory(paper, returned_rects, false);
        for (var i = 0; i < rects.length; i++) {
          var r = rects[i];

          var piece_size = parseInt(Math.random() * 10 + 20, 10);

          var b = getBox(r),x=b[0],y=b[1],w=b[2],h=b[3];

          if (Math.random() < explodability && !r.children) {
            explodeRect(r, piece_size, newRect);
          }


        }

        return returned_rects;
      }

      function openBooths(paper, rects, boardwalks) {
        var returned_rects = [];
        var newRect = newRectFactory(paper, returned_rects, false);


        // Draw another square inside this one
        function addBooth(rect, up) {

          var r = rect;
          var b = getBox(r),x=b[0],y=b[1],w=b[2],h=b[3];

          var booth_width = w / fuzzy(4);
          var booth_height = h / fuzzy(4);
          var booth_offset_x = w / fuzzy(8),
              booth_offset_y = h / fuzzy(8);

          var booth = newRect(
            x + booth_offset_x,
            y + booth_offset_y,
            booth_width,
            booth_height);

          r.attr("stroke-style", "3px");

          colorRect(booth);

        }

        for (var i = 0; i < rects.length; i++) {
          var r = rects[i];
          var booth_size = 300;
          var boothiness = 0.1;
          var b = getBox(r),x=b[0],y=b[1],w=b[2],h=b[3];

          if (Math.random() < boothiness && w > booth_size && h > booth_size) {
            addBooth(r, 4);
          }

        }

      }

      function almost() {
        return Math.random() < 0.5 ? 1 : -1;
      }

      function paveBoardwalks(paper, rects) {
        var pw = paper.width,
            ph = paper.height;

        var ret = [];
        var newRect = newRectFactory(paper, ret, false);
        function paveBoardwalk(boardwalk_size, x, y, w, h) {
          x = rounded(x, boardwalk_size * 2);
          y = rounded(y, boardwalk_size * 2);

          var r = newRect(x, y, w, h);
          explodeRect(r, boardwalk_size, newRect, true);
        }

        for (var i = 0; i < rects.length; i++) {
          var r = rects[i];
          var boardwalk_size = 20;
          var b = getBox(r),x=b[0],y=b[1],w=b[2],h=b[3];
          if (w > pw / 5) {
              paveBoardwalk(boardwalk_size, x, y, w, boardwalk_size);
              paveBoardwalk(boardwalk_size, x, y + h, w, boardwalk_size);
          }

          if (h > ph / 7) {
            paveBoardwalk(boardwalk_size, x, y, boardwalk_size, h);
            paveBoardwalk(boardwalk_size, x + w, y, boardwalk_size, h);
          }
        }

        return ret;
      }
    </script>

    <script>
      var w = screen.availWidth, h = screen.availHeight;

      var paper = Raphael(0, 0, w, h);
      var boogie = Math.random() > 0.5;
      var min_splits = boogie ? 20 : 5;
      var splits = Math.random() * min_splits + min_splits;

      var skeleton_rects = buildSkeletonRects(paper, splits, boogie);
      if (boogie) {
        var boardwalks = paveBoardwalks(paper, skeleton_rects);
        var booths = openBooths(paper, skeleton_rects, boardwalks);
      } else {
        var exploded_rects = explodeRects(paper, skeleton_rects);
        var painted_rects = paintRects(skeleton_rects);
//        var textured_rects = textureRects(painted_rects);
      }
    </script>
  </body>
</html>
